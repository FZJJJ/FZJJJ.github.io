## **函数高级**

- 函数默认参数
  1. 如果某个位置有默认参数，那么从这个位置向后都必须要有默认值（无论是函数声明或是函数实现）。
  2. 如果函数声明处有默认值，那么函数实现不可以有默认值，否则对编译器产生了二义性。
- 函数的占位参数
  1. 函数的形参列表可以有占位参数，调用的时候必须填补此位置。
  2. 占位参数也可以有默认值。
- 函数重载
  1. 函数名可以相同，用来提高复用性。
  2. 满足条件：
     - 同一个作用域下
     - 函数名称相同
     - 函数*参数* **类型**不同或者**个数**不同或者**顺序**不同
  3. 函数返回值不作为函数重载的条件。
  4. **注意事项**
     - 总体上来说就是二义性的判断
     - 引用作为重载条件时，注意引用传递时的const
     - 遇到带默认参数时的歧义

## **类和对象**

> 封装、继承与多态

第一个类：

```cpp
class Circle
{
    //访问权限
    //公共权限
public:
    //属性
    int m_r;
    //方法
    double cal_ZC()
    {
        return 2 * PI * m_r;
    }
};

int main(int argc, char const *argv[])
{
    Circle c1;//实例化
    c1.m_r = 3;//给属性“半径”赋值
    cout << c1.cal_ZC() << endl;//调用“求周长”方法
    return 0;
}
```

类中的属性和行为都称为成员，行为也称为成员函数或成员方法。

关于封装有何意义？



访问权限：

1. 公共权限（public）----成员在类内可以访问、类外也可以访问
2. 保护权限（protected）----成员在类内可以访问、类外不可以，子类可以访问父类的保护内容
3. 私有权限（private）----成员在类内可以访问、类外不可以，子类不可访问父类私有内容



CPP里*结构体*和*类*的区别与联系？

唯一的区别在于**默认的访问权限**不同。

```cpp
class C{
    int m_x;//默认private
};

struct S{
    int m_x;//默认public
};
int main(int argc, char const *argv[])
{
    C c1;
    // c1.m_x (Inaccessible);
    S c2;
    c2.m_x = 100;
    return 0;
}
```



成员属性一般设置为私有，可以利用公用的方法去单独对属性进行可读或可写的区分：

1. 可以自己控制读写权限
2. 对于写的权限，可以检测数据的有效性



**对象的初始化和清理**

利用构造函数和析构函数，编译器会自动提供其*空实现*

- 构造函数：作用在于创建对象时为对象的成员属性赋值，由编译器自动调用，无需手动调用
- 析构函数：作用在于对象**销毁前**系统自动调用，执行一些清理工作



**构造函数语法**：类名(){}

1. 无返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，可发生重载
4. 程序在调用对象时会自动调用构造，无需手动调用，且只会调用一次



**析构函数语法**：~类名(){}

1. 无返回值也不写void
2. 函数名称与类名相同且在前面加～
3. 构造函数不可以有参数，不可发生重载
4. 程序在对象销毁前会自动调用析构，无需手动调用，且只会调用一次



**构造函数的分类及调用**：

分类方式：

- 按参数：有参构造和无参构造
- 按类型：普通构造和拷贝构造

调用方式：

- 括号法
- 显示法
- 隐式转换法

---



## **STL**（Standard Template Library，标准模版库）

> 为了提高代码的复用性，为建立数据结构和算法的一套标准而诞生了STL

广义分为三部分：

- 容器
- 算法
- 迭代器

**容器**和**算法**之间通过**迭代器**而无缝连接



### STL六大组件

**容器、算法、迭代器、仿函数、适配器、空间配置器**

1. 容器：各种数据结构，如vector、list、deque、set、map，用以存放数据
2. 算法：各种常见的算法，如sort、find、copy、for_each
3. 迭代器：扮演容器与算法之间的胶合剂
4. 仿函数：行为类似函数，可作为算法某种策略
5. 适配器：一种用以修饰容器或仿函数或迭代器接口的东西
6. 空间配置器：负责空间的配置与管理



**容器**：

- 序列式容器：强调值的顺序，各元素有固定的位置
- 关联式容器：二叉树结构，各元素之间无严格的物理顺序关系

**算法**：

- 质变算法：运算过程中改变区间内元素的内容，如拷贝、替换、删除
- 非质变算法：不改变元素的内容，如查找、计数、循环、遍历等

**迭代器种类**：

|      种类      |                          功能                          |                支持运算                |
| :------------: | :----------------------------------------------------: | :------------------------------------: |
|   输入迭代器   |                     对数据只读访问                     |         只读，支持++、==、！=          |
|   输出迭代器   |                    对数据的只写访问                    |              只写，支持++              |
|   前向迭代器   |               读写操作，能向前推进迭代器               |         读写，支持++、==、！=          |
|   双向迭代器   |               读写操作，能向前和向后推进               |            读写，支持++、--            |
| 随机访问迭代器 | 读写操作，可以以跳跃方式任意访问数据，功能最强的迭代器 | 读写，支持++、--、[n]、-[n]、<,<=,>,>= |

*常用容器中迭代器种类为双向迭代器和随机访问迭代器*

---

### vector容器

```cpp
void test(){
    //创建容器
    vector<int> v;
    //插入值
    v.push_back(10);
    v.push_back(20);
    v.push_back(15);
    //利用迭代器遍历容器
    for (vector<int>::iterator it = v.begin();it != v.end();it++)
    {
        cout << *it << endl;
    }
    //调用函数遍历
    for_each(v.begin(), v.end(), myPrint); 
}
```

vector容器的**构造函数：**

1. 直接构造	`vector<int> v`
2. 通过区间方式构造（类似于Python列表的切片）    `vector <int> v2(v.begin(), v.end())`
3. 利用n个元素去构造    `vector<int> v3(10, 100)`
4. 拷贝构造    `vector<int> v4(v3)`				

---

### deque容器

可近似看成双端开口的vector容器

**工作原理**：

内部有个中控器，维护每段缓冲区的内容，缓冲区存放真实数据

中控器维护每个缓冲区的地址，使得deque好像一块连续的内存空间

- 该容器的迭代器也支持随机访问

vector容器的**构造函数：**

1. 直接构造	`deque<int> d`
2. 通过区间方式构造（类似于Python列表的切片）    `deque<int> d2(d.begin(), d.end())`
3. 利用n个元素去构造    `deque<int> d3(10, 100)`
4. 拷贝构造    `deque<int> d4(d3)`		



赋值操作：

- Operator "=" 重载
- assign（区间）或assign(n, elem)

和vector一样



大小操作：

- `duque.empty()//是否为空`
- `duque.size()//查看大小`
- `duque.resize()//重新规定大小`
- `duque.resize(num, elem)`

注意和vecctor不同的是，该容器无capacity方法，因为其容量可无限增加



插入和删除操作：

两端：

- `push_back(elem)//尾部插入`

- `push_front(elem)//头部插入`
- `pop_back()//尾部删除`
- `pop_front()//头部删除`

指定位置：

- `insert(pos, elem)//pos位置插入elem拷贝，且返回elem`
- `insert(pos, n, elem)//pos位置插入n个elem，无返回值`
- `insert(pos, begin, end)//pos位置插入[begin, end)区间，无返回值`
- `clear()//清除整个容器内容`
- `erase(begin, end)//删除[begin, end)区间，返回下一个值`
- `erase(pos)//删除pos位置数据，返回下一个值`

注意插入时的pos位置应该是迭代器提供，而非是索引值！



数据存取操作：

- `at(int index)//返回索引值为index的数据`
- `operator[]//返回索引值index的数据`
- `front()//返回第一个数据`
- `back()//返回最后一个数据`



排序操作：

- `sort(d.begin(), d.end())//默认升序排列`

sort算法支持随机访问迭代器的容器排序，deque、vector等



### stack容器

---

先进后出的数据结构，只有一个出口

只有栈顶的元素才可以被外界使用，因此不允许栈有遍历
